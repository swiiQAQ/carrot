---
title: 闭包
date: 2017-09-21 00:07:58
tags:
---
### 执行上下文
在创建一个函数时，会产生相对应的执行上下文。
```HTML
var color = 'blue';

function changeColor() {
    var anotherColor = 'red';

    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
    }

    swapColors();
}

changeColor();
```
具体顺序为：
1、在该环境中，首先是是全局上下文，然后是changeColor的执行上下文，最后是swapColors的执行上下文，依次进入堆栈。
2、在退出函数时，该函数的执行上下文也被pop出来，知道最后是全局上下文。
3、全局上下文只要页面不关闭，都是一直存在的。
### 变量对象
变量对象的创建，依次经历了以下几个过程。
1、建立参数对象
2、检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。
3、检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。
>像这种将后面的变量声明放在执行语句前面声明的行为叫变量提升
下面举例：
```HTML
function test() {
    console.log(foo);
    console.log(bar);

    var foo = 'Hello';
    console.log(foo);
    var bar = function () {
        return 'world';
    }

    function foo() {
        return 'hello';
    }
}

test();
```
1、进入创建阶段，先进行function的声明，所以foo此时是个函数
2、进行foo和bar的赋值，发现foo已经是个函数了，所以跳过重新声明，而bar被声明为undefined
3、进入执行阶段，所以第一遍打印出来是foo (){return 'world'}
4、第二遍打印为undefined
5、然后foo被赋值为hello
6、第三遍打印为Hello
### 执行上下文和变量对象、作用域链、this的关系
每个执行上下文都有以下三个属性：

1、变量对象：存储了上下文中定义的变量和函数声明，在函数定义阶段是变量对象；在执行阶段是活动对象。
2、作用域链：作用域链是保证执行上下文有权访问的所有变量和函数的有序访问。 最上面的栈是当前函数的变量对象，然后是父级上下文的变量对象，最后是全局变量对象。
3、this
### 闭包
#### 什么是闭包
闭包是指有权访问另一个函数作用于中的变量的函数。
通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。
#### 需要闭包的理由
局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。
#### 闭包的缺点
闭包的缺点就是常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露。
如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。
#### 使用方法
1.定义外层函数，封装被保护的局部变量。 
2.定义内层函数，执行对外部函数变量的操作。 
3.外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。
#### 使用例子
```HTML
var x=10;
function foo(a){
    var b=20;
    function bar(c){
        var d=30;
        return boop(x+a+b+c+d);
    }
    function boop(e){
        return e * -1;
    }
    return bar;
}

var moar=foo(5); // 闭包
moar(15); //-80
```
foo(5)执行的时候，将a,b的值存在闭包里面,等到执行moar(15)时再将15传入bar中，最终x,a,b,c,d的值都获取到了
![](/img/closure.png '调试器中观察闭包')

#### 闭包中的this对象
```HTML
var name = "The Window";
var obj = {
    name: "My Object",
  
    getName: function(){
        return function(){
            return this.name;
        };
    },
    getObjName: function(){
        var _this = this;
        return function(){
            return _this.name;
        }
    }
};
console.log(obj.getName()());  // The Window
console.log(obj.getObjName()()); //My Object
```
匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。
而事先将this存在_this中，此时的this指向的是obj对象。
#### setTimeout循环和闭包的经典例子

##### setTimeout的执行时间
```HTML
setTimeout(function(){
    console.log("third")
},100)
setTimeout(function(){
    console.log("second")
},0)
console.log("first")
```
即使第二个定时器的执行时间是0，但是只要是关于定时器的操作，都是在所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。
而关于定时器的执行顺序是push至队列中，而这些操作进入队列的顺序，则由设定的延迟时间来决定。
所以最终显示的结果是first second third
##### 例子解析
```HTML
for (var i=1; i<=5; i++) { 
    setTimeout( function timer() {
        console.log(i);
    }, i*1000 );
}
// 6 6 6 6 6
```
```HTML
for (var i=1; i<=5; i++) { 
    setTimeout( function timer(i) {
        console.log(i);
    }(i), i*1000 );
}
// 1 2 3 4 5
```
在第一个段代码中，因为定时器会在所有操作完毕后再执行，所以在执行timer的时候，外部的i已经循环完了，
所以循环五遍打印出来的都是最后一位数，即6.
而在第二段的代码中，使用自执行函数将i保存在闭包中，当setTimeout中定义的操作执行时，则访问对应闭包保存的i值即可。
#### 关于闭包的偏函数应用
##### 什么是偏函数应用
一个过程，它传给某个函数其中一部分参数，然后返回一个新的函数，该函数等待接受后续参数。换句话说，偏函数应用是一个函数，它接受另一个函数为参数，这个作为参数的函数本身接受多个参数，它返回一个函数，这个函数与它的参数函数相比，接受更少的参数。偏函数应用提前赋予一部分参数，而返回的函数则等待调用时传入剩余的参数。
##### 偏函数的例子
```HTML
function fun(n,o){
  console.log(o);
  return {
    fun: function(m){
      return fun(m,n);
    }
  };
}

var a = fun(0);  // undefined
a.fun(1);        // 0        
a.fun(2);        // 0
a.fun(3);        // 0

var b = fun(0).fun(1).fun(2).fun(3);  // undefined 0 1 2

var c = fun(0).fun(1);  // undefined 0
c.fun(2);        // 1
c.fun(3);        // 1
```