---
title: 关于全屏滚动切换开发中碰到的知识点
date: 2017-09-08 15:46:42
tags:
---
### 1.关于(function(){})()自执行函数
```HTML
var a = (function(){
	return 'swii';
})()
var b = (function(){
	return {
		name: "swii"
	};
})();
var c = (function(){
	return{
		showName: function(){
			console.log('swii');
		}
	}
})();
```
a	string
b	Object
C	Object
b.name	String 
C.showName	function

除了return的内容，其他的内容都是私有的；

```HTML
var mySingleton = function(){
	var privateVariable = 'private';
	function showPrivate(){
		console.log(privateVariable);
	}
	return {
		publicMethod: function(){
			showPrivate();
		},
		publicVar: 'the public can see this'
	};
};
var single = mySingleton();
single.publicMethod();
console.log(single.publicVar);
```

privateVariable是私有变量
showPrivate是私有方法
只有return里面的publicMethod是公有方法，publicVar是公有变量

```HTML
var singletonTester = (function(){
function singleton(args){
	var args = args || {};
	this.name = 'SingletonTester';
	this.pointX = args.pointX || 6;
	this.pointY = args.pointY || 10;
}
var instance;
var _static = {
	getInstance: function(args){
		if(instance === undefined){
		instance = new singleton(args);
		}
	return instance;
	}
}
return _static;
})();
var singletonTest = singletonTester.getInstance({pointX:10});
console.log(singletonTest);
```

### 2.闭包的作用：
1、避免全局依赖
2、避免第三方破坏
3、兼容jquery操作符$和jquery

### 3.单例模式
```HTML
$.fn.MyPlugin = function(){
	Var me = $(this),
	Instance = me .data("myPlugin");
	If(!instance){
		Me.data("myPlugin",(instance = new myPlugin()));
	} 
}
```
如果实例存在则不再重新创建实例，利用data()来存放插件对象的实例

### 4.深拷贝和浅拷贝：
浅拷贝类似于引用类型只是复制了地址，但是两个变量指向的还是同一个地址
而深拷贝则是新变量与旧变量的地址不同，独立存在的。

### 5.$.fn===$.prototype
 
### 6.jquery方法 data()
```HTML
$(selector).Data(name,value)	设置value
$(selector).Data(name)	取出value
Var obj = new Object();
Obj.say="say sth";
Obj.play="play sth";
$(selector).data(obj);
Alert($(selector).data("say"))     //say sth
```
### 7.jquery方法 $.extend()
1、$.extend(dest,src1,src2)
将src1和src2合并至dest中；得到的结果也是dest

Var result = $.extend({},{name:"tom",age:21},{name:"jerry",animal:"mouse"})    
//result: {name:"jerry",age:21,animal:"mouse"}

如果后面的参数和前面的参数有重复的话，后面的会覆盖前面的，得到最终的是合并的结构
2、$.extend(src)
将src合并到jquery的全局对象中
$.extend({
	hello: function(){console.log("hello")}
});
$.hello()    //hello
3、$.fn.extend(src)
将src合并到jquery的实例对象中
```HTML
$.fn.extend({
	hello: function(){
		Console.log("hello")
	}
})
$("selector").hello()     //hello
```
4、$.extend(boolean,dest,src1,src2)
  第一个参数boolean代表是否进行深度拷贝，其余参数和前面介绍的一致，什么叫深层拷贝，我们看一个例子：
```HTML
var result=$.extend( true, {}, 
{ name: "John", location: {city: "Boston",county:"USA"} }, 
{ last: "Resig", location: {state: "MA",county:"China"} } );
```

我们可以看出src1中嵌套子对象location:{city:"Boston"},src2中也嵌套子对象location:{state:"MA"}。
第一个深度拷贝参数为true，那么合并后的结果就是： 
```HTML
result={name:"John",last:"Resig",
location:{city:"Boston",state:"MA",county:"China"}}
```
也就是说它会将src中的嵌套子对象也进行合并，而如果第一个参数boolean为false，我们看看合并的结果是什么，如下：
```HTML
var result=$.extend( false, {}, 
{ name: "John", location:{city: "Boston",county:"USA"} }, 
{ last: "Resig", location: {state: "MA",county:"China"} } 
);
```
那么合并后的结果就是:
result={name:"John",last:"Resig",location:{state:"MA",county:"China"}}


### 8.滚轮事件
关于滚轮事件，除了火狐浏览器，其他浏览器都是通过wheeldalta来判断，火狐浏览器通过detail
向下滚动时，wheeldalta为-120，detail为3
### 9.键盘事件
js中
IE	keyCode
Firefox	which和charCode
Opera	keyCode和which等
jquery中通过.witch和.keyCode
左 37
上38
右39
下40
### 10.
类级别的开发
1、添加新的全局函数
```HTML
jQuery.foo = function() {   
 alert("This is a test.");  
};
```
	
2、增加多个全局函数
```HTML
jQuery.foo = function(){
  alert("This is a test.");  
};
jQuery.bar = function(param){
	alert("This is another test.");
}
```
调用
  $.foo();
  $.bar("bar")
		
3、使用jQuery.extend(object)添加全局函数
```HTML
jQuery.extend({
	foo:function(){
		alert("This is a test.");    
	},
	bar:function(){
		alert("This is another test");
	}
});
```
4、使用命名空间
```HTML
jQuery.myPlugin = {
   foo:function(){
       alert("This is a test.");
   },
    bar:function("bar"){
       alert("This is another test.");
   }  
}
```
调用
	$.myPlugin.foo();
	$.myPlugin.bar("bar");
		
		
对象级别的插件开发
1、
```HTML
(function($){
    $.fn.pluginName = function(){
    	// 插件代码写在这里 
	}
})(jQuery);
```
上面定义了一个jQuery函数，形参是$,函数定义完成后，把jQuery这个实参传递进去，立即调用执行，这样的好处是我们在写jQuery插件时，也可以使用$这个别名，而不会与prototype引起冲突。

调用
	$("nav").pluginName()
2、接受options参数移控制插件的行为

